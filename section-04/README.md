> Tags: Operating Systems, RTOS, Embedded, Scheduling, Mutex, Semaphore

# Operating Systems

This section introduces the fundamentals of operating systems, with a focus on embedded and real-time systems. You will learn about system calls, the kernel, scheduling, concurrency, and synchronization mechanisms such as mutexes and semaphores.

## 0. What is an Operating System?

An Operating System (OS) is a collection of software services that bridge the gap between hardware and software. For example, when a high-level program prompts the user for input or displays graphics, it relies on OS routines to handle these operations.

## 0.1 System Calls (Syscalls)

System calls are the interface between user programs and the OS. They allow user-space programs to request services from the OS, such as input/output, file access, or network communication. For example, when your program displays data on the screen, the code generated by the compiler will include (among other things) system calls to the OS to handle this output.

**In summary:**

- User programs run in a sandbox and can only access their own memory and functions.
- To interact with the outside world (screen, files, sound, network), a program must use system calls.

## 0.2 The Kernel

The kernel is the core of the operating system. It has complete control over the system and manages hardware resources. The kernel is typically loaded after the bootloader during system startup.

> [!NOTE]
> For more on kernel-level security, see [kernel-level anticheats](https://gist.github.com/stdNullPtr/2998eacb71ae925515360410af6f0a32).

Further reading: https://cpu.land/

## 1. Types of Operating Systems

### 1.1 General Purpose Operating Systems

General purpose operating systems are designed for desktops, laptops, and servers. Their main goal is to prioritize fairness, making sure that all applications eventually get access to system resources. Some common examples of general purpose operating systems are Windows, Linux, and macOS.

### 1.2 Real-Time Operating Systems (RTOS)

Real-time operating systems are designed for embedded systems and devices that have strict timing deadlines. These systems prioritize determinism, which means that tasks must run within specific timing guarantees. Real-time operating systems are commonly used in automotive electronics, robotics, aerospace, and Internet of Things (IoT) devices.

So at this point, you may be asking yourself the million dollar question:

# Why Use an RTOS Instead of Just a While Loop?

A simple infinite `while` loop works for basic embedded projects with few tasks and loose timing. However, as complexity grows, this approach quickly becomes unmanageable. An RTOS solves these issues by providing:

- **Task Scheduling:** Built-in real-time scheduler manages timing and task priorities, making code more predictable and maintainable.
- **Modularity:** Code is organized into independent tasks, reducing interdependencies and simplifying testing, collaboration, and code reuse.
- **Efficiency:** Tasks can block on events, eliminating wasteful polling and enabling low-power operation when idle.
- **Flexible Interrupt Handling:** Processing can be deferred to tasks, keeping interrupt handlers short and system responsive.
- **Mixed Workloads:** Supports periodic, event-driven, and continuous tasks, meeting both hard and soft real-time requirements.

## 2. Key Features of an RTOS

The scheduler is a key feature of any operating system. It divides CPU time into slices and determines which task should run at any given moment. Most operating systems use priority-based execution, where the highest-priority task runs first at each tick of the system timer. Even on a single-core CPU, the operating system rapidly switches between tasks, creating the illusion that multiple tasks are running at the same time. This is known as the concurrency illusion.

## 3. Tasks, Threads, and Processes

These three concepts are fundamental to understanding how operating systems manage work:

- **Task:** In embedded and RTOS contexts, a "task" is a unit of work scheduled by the OS, similar to a lightweight thread. For example, reading sensor data or handling communication can each be a separate task.

- **Thread:** A thread is the smallest sequence of programmed instructions that can be managed independently by the scheduler. Threads within the same process share memory and resources but have their own program counter and stack.

- **Process:** A process is an independent program in execution, with its own memory space and resources. A process can contain multiple threads that work together to perform tasks.

## 4. Tick Timer and Context Switching

The tick timer is a hardware timer that interrupts the CPU at fixed intervals, much like a metronome keeps time in music. At each tick, the scheduler evaluates the priorities of all tasks and decides which one should run next. When the operating system switches from one task to another, it performs a context switch. This means the system saves the current task's CPU registers, program counter, and local variables, and then restores these values for the next task to run.

## 5. Synchronization: Mutexes and Semaphores

### 5.1 Mutex

A mutex is a synchronization tool that ensures only one thread can enter a protected section of code at a time. It uses atomic instructions, which means the operation cannot be split up or interrupted. This is important for protecting critical sections: parts of the code that must run from start to finish without interruption. If multiple threads try to access a critical section at the same time, they can corrupt shared variables. Mutexes prevent this from happening.

### 5.2 Semaphore

A semaphore is a counter that controls access for multiple threads. For example, imagine a room (the critical section) that allows up to three people (threads) inside at once. There are three keys (the semaphore count), and each person must take a key to enter. If all the keys are taken, anyone else who wants to enter must wait until a key is returned. This is how semaphores help manage access to shared resources.

## 6. Scheduling Issues

Priority inversion happens when a low-priority task holds a mutex, and a high-priority task has to wait for it. This problem can be solved with a technique called priority inheritance, where the low-priority task temporarily inherits the higher priority. Starvation occurs when some tasks never get CPU time because higher-priority tasks are always running. This can be fixed by "aging," which means gradually raising the priority of tasks that have been waiting a long time. Deadlock is a situation where tasks are stuck waiting on each other, so nothing can proceed. One way to break a deadlock is to use timeouts, which halt all the tasks and try again later.

## 7. FreeRTOS

## 8. Further Reading

- [RTOS Fundamentals](https://freertos.org/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals)
